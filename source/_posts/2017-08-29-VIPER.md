title: VIPER
date: 2017-08-29 20:45:12
tags:
  - VIPER
  - architecture
  - self learning
---

First of all; this is not «_Yet another VIPER[^1] blog post_»*™* but more like «_What did I learn while trying VIPER[^1]_» kind of blog post.

That being said; we can't jump straight into `VIPER`[^1] without giving it at least a small introduction; so here's the definition given by mutualmobile[^4] (allegedly `VIPER`s creators):

> **VIPER** is our application of _Clean Architecture_ to iOS apps. The word **VIPER** is a backronym for _View_, _Interactor_, _Presenter_, _Entity_ and _Routing_.
>
>  &mdash; <cite>Jeff Gilbert & Conrad Stoll[^1]</cite>

There are many good sources about `VIPER`[^1] like this article from obj.io[^2] or this amazing talk from Nicola Zaghini @ Mobilization[^3].

<!--more-->

The first thing that I grapsed about the whole definition and how to apply it to `Swift` was the fact that I would be relying alot on `protocol`s to define each and every «boundary».



## Why `protocol`s?

Basically the whole idea of `Clean Code` Architecture (or `VIPER` in this instance) is to draw almost all attention to the most important part of any application: the data and the business logic, **AND** also to define a pretty simple flow indicating the direction in which each layer can access the next one.

To put it simple, the outer layers know about their next inner layer but the inner layers can't know about the outer layers; like it's represented on this image:

![The Clean Architecture - Image from Five Agency](http://five.agency/wp-content/uploads/2016/11/Graph-1.png)[^5]

This is also know as the «*onion architecture*».

Now; as you can see if we follow the principile of only communicating towards the center (and inner layers don't know about outer layers) we won't be capable of notifying the outer layers once an inner layer operation is done.



### Dependency Inversion Principle

In order to circumvent this we need to use heavy usage of the concept of the «**Dependency Inversion**» principle.

>In object-oriented design, the **dependency inversion principle** refers to a specific form of decoupling software modules. When following this principle, the conventional dependency relationships established from high-level, policy-setting modules to low-level, dependency modules are reversed, thus rendering high-level modules independent of the low-level module implementation details.
>
>![Dependency Inversion Figure](https://upload.wikimedia.org/wikipedia/commons/9/96/Dependency_inversion.png)[^6]

As you can see; by defining interfaces (or in our case `protocol`s) we can then invert the dependencies and decouple the outer layers from the inner layers without losing the ability for the inner layers to communicate results outwards of the «onion».



## `TDD`

One of `Clean Code Architecture` «dogmas» is to `TDD`[^7], or better put, the ability to easily `TDD`[^7] your code.

This is something that I faced as soon as I started playing with `VIPER`[^1]; by defining all the «boundaries» as `protocol`s and inverting the dependencies; every dependency of a component was easily mocked[^8] which makes testing easier.

Also by defining your `protocol`s first you start thinking about how the `API` for the components is going to look, then your `unit tests` will become the first consumers of your `API` and they can show how good or bad an `API` is written even before there's an actual implementation.

By doing this you avoid coding a component just to then reach the next component that's dependent on the previous to find out that you either need to pass some extra information, you need a different set of values returned or a combination of all the possibilities.

This wasn't my first application developed relying on `TDD`[^7] but this was by far the easiest to set following this development process.

[^1]: https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework
[^2]: https://www.objc.io/issues/13-architecture/viper/
[^3]: https://academy.realm.io/posts/break-the-monoloth-with-b-viper-modules/
[^4]: https://mutualmobile.com
[^5]: http://five.agency/android-architecture-part-2-clean-architecture/
[^6]: https://en.wikipedia.org/wiki/Dependency_inversion_principle
[^7]: https://technologyconversations.com/2013/12/20/test-driven-development-tdd-example-walkthrough/
[^8]: https://en.wikipedia.org/wiki/Mock_object